
import numpy as np 
import pandas as pd
import scipy.linalg as la
import matplotlib.pyplot as plt
import matplotlib as mpl
import glob
#import nfft 
from matplotlib import cm
from matplotlib.colors import ListedColormap, LinearSegmentedColormap

import time as tm

import sys,os

class Simulation: 
    """
    A comprehensive analysis class for calculating spin wave modes in 2 dimentional structures. If the simulation 
    is a 3d simulation, the magnetization will be spatially averaged through the z-direction 
    
    Attributes:
    ---------------------------------------------------------------------------------------------------
    """
    
    def __init__(self, FolderPath, field_to_import, dataFile, titles, images = None, data = None): 
        """
        Innitialization automatically imports data, but does not automatically create Fourier Images
        
        Parameters: 
        -----------------------------------------------------------
        FolderPath: string 
            The path to the folder where the data from the desired Simulation is stored
        field_to_import: array [string, dimentions]
            The glob style file names of the magnetization fields that should be imported to be analyzed.
            For instance, Simulation1-*.odt will import all fields titled Simulation1-*.odt in the folder location
            They should be in the .otd file format and have the form: 
                x y Mx My Mz 
            with no headers and spaces as the delimiters. 
            These files should be generated by exporting the Magnetization field using mmArchive during an 
            OOMMF simulaiton. mmArchive will generate .omf files which must be converted to .odt files. 
            This form can be achieved by converting the omf files that OOMMF outputs using avf2odt from 
            the OOMMF command line commands. When in the oommf folder, the following cmd command should 
            create the correct file output: 
                tclsh oommf.tcl avf2odt -ipat "FolderPath/fileNames***.omf" -average "line" -axis "z" -header "none"
        dataFile: string
            The file name of the datatable from mmArchive. OOMMF should output an .omf file which needs no conversion to 
            be read. This file will be used to get the time of each vector magnetization field file 
        title: string (optional)
            If given, saved plots will gave the prefix of the title
            
        Initializing a simulation
        ---------------------------------------------------------------------------------------------------------
        Put all field profiles and the data output in 1 folder with nothing else. Files can be avf or odt. 
            
            
        """
        self.titles = titles #an array containind the titles of the respective fields of the simulation
        self.coords = [] # [x or y][cell position] 
        self.images = []#[Field][t][x][y][dim]
        self.v_t = [] #[Field][x][y][dim_field][t]
        self.v_s_avg = [] 
        self.core_position = [] 
        self.FolderPath = FolderPath
        self.pathToOOMMF = 'C:/Users/bgoul/Documents/oommf20a4/oommf/'
        self.dataPath = FolderPath + str(dataFile)
        gwc = np.array(field_to_import)
        dimsList = gwc[:,1]
        self.dimsList = []
        for dims_ind in range(0, len(dimsList)): 
            self.dimsList.append(int(dimsList[dims_ind]))
        
        if (data == None):  
            print("Importing Data")
            if (dataFile != None): 
                self.data = self.getData()
            else: 
                self.data = False
            print("setting time array")
        else: 
            self.data = data
        if (type(self.data) != bool): 
            if ("TimeDriver::Simulationtime" in self.data.columns): 
                self.time = self.data["TimeDriver::Simulationtime"]
            else: 
                self.time = [0]
        
        if (images == None):
            print("Importing Fields")
            for field in field_to_import: 
                print ("path0", field[0])
                print("path1", field[1])
                temp_images, temp_f_t, temp_f_s_avg = self.createImages(FolderPath + field[0], dims = field[1])
                self.images.append(temp_images)
                self.v_t.append(temp_f_t)
                self.v_s_avg.append(temp_f_s_avg)
            
        else: 
            print("Need to add import images case")
        
        self.freq = None #List of frequencies that the FFT spans 
        self.fourierImage = [None]*len(field_to_import) #[field][x][y][dim][freq]
        self.fourierPhaseImage = [None]*len(field_to_import) #[field][x][y][dim][freq]
        self.fourierImage1D = [None]*len(field_to_import) #[field][x][y][freq] spatially averaged after FFT
        self.fourierAverage = [None]*len(field_to_import) #[field][freq]
        self.dimFourierAverage = [None]*len(field_to_import)
        self.s_avg_FT = [None]*len(field_to_import)
        self.dm = [None]*len(field_to_import)
        self.sphImage = [None]*len(field_to_import)
        self.dm_sph = [None]*len(field_to_import)
        self.peaks = None
        
    def avf2odt(self): 

        """
        For Windows devices ONLY, converts OOMMF field file outputs from the .avf format (in bianary to save memory) to the .odt format 
        which python can read. 
        """

        dataPath = self.FolderPath
        suc1 = os.system('cd {} & tclsh oommf.tcl avf2odt -ipat "{}*.o*f" -average "line" -axis "z" -headers "none" '.format(self.pathToOOMMF, dataPath))
        print("exit code avf2odt: ", suc1)
#        if (suc1 == 1):
        suc2 = os.system('cd {} & mkdir avfFiles & move *.o*f avfFiles'.format(dataPath))
#        else: 
#            suc2 = -17
        print("exit code to moving avf files: ", suc2) 
            
    def createImages(self, imagePath, dims = 3, exe_avf2odt = True):
        """
        This method is used to read data from the .odt vector field files. It creates 2 multi-dimentional arrays that represent the magnetization data. 
        The method is automatically run upon innitialization of the Simulation class, so it should not be run again. 

        Parameters: None

        Returns: 
        sss: array 
            sss is a multidimentional array that contains all the data from each magnetization profile in sequential order. The shape is sss[t][x][y][m]
        m_t: array
            m_t is a multidimentional array that contains all the data from each magnetization profile in sequential order. The shape is m_t[x][y][m][t]
        """
        print("Checking and changing file format with avf2odt (may take quite a while, depending on how many files must be converted from .avf to .odt)")
        if (exe_avf2odt == True): 
            self.avf2odt()
        sss = []
        v_s_avg = []
        i = 0
        print("Importing Fields")
        if (glob.glob(imagePath) == []):
            print("List of fields is empty, check the filepath")
            
        finalList = []
        for stage in glob.glob(imagePath):
            finalList.append(stage)
        finalList = sorted(finalList)
#        print(finalList)
        for stage in finalList: 
            shot = pd.read_csv(stage, delim_whitespace=True, header = None, comment = "#")
            self.coords = (shot[0].unique(), shot[1].unique())
            num_x_cells = len(self.coords[0])
            num_y_cells = len(self.coords[1])

            image = np.zeros((num_x_cells, num_y_cells, dims))
#            s_avg = [0]*dims
            for x in range(0, num_x_cells): 
                for y in range(0, num_y_cells): 
                    num = y + x*num_y_cells
                    for dim in range(0, dims):
                        image[x][y][dim] = shot[dim+2][num]
#                        s_avg[dim] = s_avg[dim] + shot[dim+2][num]

            sss.append(image)
#            v_s_avg.append(s_avg)
            if (i%100 == 0): 
                print ("Imported ", i, "Fields")
            i += 1
        sss = np.array(sss)
#        v_s_avg = np.array(v_s_avg)
#        v_s_avg = v_s_avg / (num_x_cells*num_y_cells)
#        v_s_avg = v_s_avg.T
        v_s_avg = np.zeros([dims, len(sss)])
        for t in range(0, len(sss)): 
            for dim in range(0, dims): 
                v_s_avg[dim][t] = np.sum(sss[t,:,:,dim])
        v_t = np.zeros((num_x_cells, num_y_cells, dims, len(sss)))
        print("Transposing data")
        for x in range(0, num_x_cells): 
            for y in range(0, num_y_cells): 
                v_t[x][y] = sss[:,x,y].T
        return sss, v_t, v_s_avg

    def getData(self):
        """
        ***DOES NOT WORK AT THE MOMENT***
        This method reads the data from the DataTable output by mmArchive from OOMMF. 
        This method is run on initialization of the Simulation class, so it should not be run again. 
        This needs to be edited so that it can read the titles of the data array. Right now, it does not work

        Parameters: Nothing

        Returns: 
        data: array 
            The data table output by OOMMF as an array
        """
        lines = []
        with open(self.dataPath, 'r+') as f:
            lines = f.readlines()
        with open(self.dataPath, 'w') as fp:
            for number, line in enumerate(lines):
                # delete line 5 and 8. or pass any Nth line you want to remove
                # note list index starts from 0
                if (number not in [3]):
                    fp.write(line)
                elif (line[0] == "#"): 
                    toWrite = line[10:]
                    toWrite = toWrite.replace("{", "")
                    toWrite = toWrite.replace(" ", "")
                    toWrite = toWrite.replace("}", "")
                    toWrite = toWrite.replace("Oxs_", " ")

                    fp.write(toWrite)
                else: 
                    fp.write(line)
        
        data = pd.read_csv(self.dataPath, delim_whitespace = True, comment = "#", header = 0)
        return data

"""3D doesn't work right now"""

class Simulation3D: 
    """
    A comprehensive analysis class for calculating spin wave modes in 2 dimentional structures 
    
    Attributes:
    ---------------------------------------------------------------------------------------------------
    """
    
    def __init__(self, FolderPath, field_to_import, dataFile, titles, images = None, data = None): 
        """
        Innitialization automatically imports data, but does not automatically create Fourier Images
        
        Parameters: 
        -----------------------------------------------------------
        FolderPath: string 
            The path to the folder where the data from the desired Simulation is stored
        field_to_import: array [string, dimentions]
            The glob style file names of the magnetization fields that should be imported to be analyzed.
            For instance, Simulation1-000000***-********.odt will import the first 1000 fields in the folder location
            They should be in the .otd file format and have the form: 
                x y Mx My Mz 
            with no headers and spaces as the delimiters. 
            These files should be generated by exporting the Magnetization field using mmArchive during an 
            OOMMF simulaiton. mmArchive will generate .omf files which must be converted to .odt files. 
            This form can be achieved by converting the omf files that OOMMF outputs using avf2odt from 
            the OOMMF command line commands. When in the oommf folder, the following cmd command should 
            create the correct file output: 
                tclsh oommf.tcl avf2odt -ipat "FolderPath/fileNames***.omf" -average "line" -axis "z" -header "none"
        dataFile: string
            The file name of the datatable from mmArchive. OOMMF should output an .omf file which needs no conversion to 
            be read. This file will be used to get the time of each vector magnetization field file 
        title: string (optional)
            If given, saved plots will gave the prefix of the title
            
        Initializing a simulation
        ---------------------------------------------------------------------------------------------------------
        Put all field profiles and the data output in 1 folder with nothing else. Files can be avf or odt. 
            
            
        """
        self.titles = titles
        self.coords = []
        self.images = []
        self.v_t = [] #[Field][x][y][dim_field][t]
        self.v_s_avg = []
        self.core_position = []
        self.FolderPath = FolderPath
        self.pathToOOMMF = 'C:/Users/bgoul/Documents/oommf20a4/oommf/'
        self.dataPath = FolderPath + dataFile
        gwc = np.array(field_to_import)
        dimsList = gwc[:,1]
        self.dimsList = []
        for dims_ind in range(0, len(dimsList)): 
            self.dimsList.append(int(dimsList[dims_ind]))
        
        if (data == None):  
            print("Importing Data")
            self.data = self.getData()
            print("setting time array")
        else: 
            self.data = data
        if ("TimeDriver::Simulationtime" in self.data.columns): 
            self.time = self.data["TimeDriver::Simulationtime"]
        else: 
            self.time = [0]
        
        if (images == None):
            print("Importing Fields")
            for field in field_to_import: 
                print ("path0", field[0])
                print("path1", field[1])
                temp_images, temp_f_t, temp_f_s_avg = self.createImages(FolderPath + field[0], dims = field[1])
                self.images.append(temp_images)
                self.v_t.append(temp_f_t)
                self.v_s_avg.append(temp_f_s_avg)
            
        else: 
            print("Need to add import images case")
        
        self.freq = None #List of frequencies that the FFT spans 
        self.fourierImage = [None]*len(field_to_import) #[field][x][y][dim][freq]
        self.fourierPhaseImage = [None]*len(field_to_import) #[field][x][y][dim][freq]
        self.fourierImage1D = [None]*len(field_to_import) #[field][x][y][freq] spatially averaged after FFT
        self.fourierAverage = [None]*len(field_to_import) #[field][freq]
        self.dimFourierAverage = [None]*len(field_to_import)
        self.s_avg_FT = [None]*len(field_to_import)
        self.peaks = None
        
    def avf2odt(self): 
        dataPath = self.FolderPath
        suc1 = os.system('cd {} & tclsh oommf.tcl avf2odt -ipat "{}*.o*f" -average "point" -headers "none" '.format(self.pathToOOMMF, dataPath))
        print("exit code avf2odt: ", suc1)
#        if (suc1 == 1):
        suc2 = os.system('cd {} & mkdir avfFiles & move *.o*f avfFiles'.format(dataPath))
#        else: 
#            suc2 = -17
        print("exit code to moving avf files: ", suc2) 
            
    def createImages(self, imagePath, dims = 3, exe_avf2odt = True):
        """
        This method is used to read data from the .odt vector field files. It creates 2 multi-dimentional arrays that represent the magnetization data. 
        The method is automatically run upon innitialization of the Simulation class, so it should not be run again. 

        Parameters: None

        Returns: 
        sss: array 
            sss is a multidimentional array that contains all the data from each magnetization profile in sequential order. The shape is sss[t][x][y][m]
        m_t: array
            m_t is a multidimentional array that contains all the data from each magnetization profile in sequential order. The shape is m_t[x][y][m][t]
        """
        print("Checking and changing file format with avf2odt (may take quite a while, depending on how many files must be converted from .avf to .odt)")
        if (exe_avf2odt == True): 
            self.avf2odt()
        sss = []
        v_s_avg = []
        i = 0
        print("Importing Fields")
        if (glob.glob(imagePath) == []):
            print("List of fields is empty, check the filepath")
            
        finalList = []
        for stage in glob.glob(imagePath):
            finalList.append(stage)
        for stage in finalList: 
            shot = pd.read_csv(stage, delim_whitespace=True, header = None, comment = "#")
            self.coords = (shot[0].unique(), shot[1].unique(), shot[2].unique())
            num_x_cells = len(self.coords[0])
            num_y_cells = len(self.coords[1])
            num_z_cells = len(self.coords[2])
            print(num_x_cells, num_y_cells, num_z_cells)

            image = np.zeros((num_x_cells, num_y_cells, num_z_cells, dims))
#            s_avg = [0]*dims
            for x in range(0, num_x_cells): 
                for y in range(0, num_y_cells): 
                    for z in range(0, num_z_cells): 
                        num = x + y*num_x_cells + z*num_x_cells*num_y_cells
                        for dim in range(0, dims):
                            image[x][y][z][dim] = shot[dim+3][num]
    #                        s_avg[dim] = s_avg[dim] + shot[dim+2][num]

            sss.append(image)
#            v_s_avg.append(s_avg)
            if (i%100 == 0): 
                print ("Imported ", i, "Fields")
            i += 1
        sss = np.array(sss)
#        v_s_avg = np.array(v_s_avg)
#        v_s_avg = v_s_avg / (num_x_cells*num_y_cells)
#        v_s_avg = v_s_avg.T
        v_s_avg = np.zeros([dims, len(sss)])
        for t in range(0, len(sss)): 
            for dim in range(0, dims): 
                v_s_avg[dim][t] = np.sum(sss[t,:,:,:,dim])
        v_t = np.zeros((num_x_cells, num_y_cells, num_z_cells, dims, len(sss)))
        print("Transposing data")
        for x in range(0, num_x_cells): 
            for y in range(0, num_y_cells): 
                v_t[x][y][z] = sss[:,x,y,z].T
        return sss, v_t, v_s_avg

    def getData(self):
        """
        ***DOES NOT WORK AT THE MOMENT***
        This method reads the data from the DataTable output by mmArchive from OOMMF. 
        This method is run on initialization of the Simulation class, so it should not be run again. 
        This needs to be edited so that it can read the titles of the data array. Right now, it does not work

        Parameters: Nothing

        Returns: 
        data: array 
            The data table output by OOMMF as an array
        """
        lines = []
        with open(self.dataPath, 'r+') as f:
            lines = f.readlines()
        with open(self.dataPath, 'w') as fp:
            for number, line in enumerate(lines):
                # delete line 5 and 8. or pass any Nth line you want to remove
                # note list index starts from 0
                if (number not in [3]):
                    fp.write(line)
                elif (line[0] == "#"): 
                    toWrite = line[10:]
                    toWrite = toWrite.replace("{", "")
                    toWrite = toWrite.replace(" ", "")
                    toWrite = toWrite.replace("}", "")
                    toWrite = toWrite.replace("Oxs_", " ")

                    fp.write(toWrite)
                else: 
                    fp.write(line)
        
        data = pd.read_csv(self.dataPath, delim_whitespace = True, comment = "#", header = 0)
        return data

class Simulation3D_OLD: 
    """
    A comprehensive analysis class for calculating spin wave modes in 2 dimentional structures 
    """
    
    def __init__(self, FolderPath, field_to_import, dataFile, titles, images = None, data = None): 
        """
        Innitialization automatically imports data, but does not automatically create Fourier Images
        
        Parameters: 
        -----------------------------------------------------------
        FolderPath: string 
            The path to the folder where the data from the desired Simulation is stored
        field_to_import: array [string, dimentions]
            The glob style file names of the magnetization fields that should be imported to be analyzed.
            For instance, Simulation1-000000***-********.odt will import the first 1000 fields in the folder location
            They should be in the .otd file format and have the form: 
                x y Mx My Mz 
            with no headers and spaces as the delimiters. 
            These files should be generated by exporting the Magnetization field using mmArchive during an 
            OOMMF simulaiton. mmArchive will generate .omf files which must be converted to .odt files. 
            This form can be achieved by converting the omf files that OOMMF outputs using avf2odt from 
            the OOMMF command line commands. When in the oommf folder, the following cmd command should 
            create the correct file output: 
                tclsh oommf.tcl avf2odt -ipat "FolderPath/fileNames***.omf" -average "line" -axis "z" -header "none"
        dataFile: string
            The file name of the datatable from mmArchive. OOMMF should output an .omf file which needs no conversion to 
            be read. This file will be used to get the time of each vector magnetization field file 
        title: string (optional)
            If given, saved plots will gave the prefix of the title
            
            
        """
        self.titles = titles
        self.coords = []
        self.images = []
        self.v_t = [] #[Field][x][y][z][dim_field][t]
        self.v_s_avg = []
        self.core_position = []
        self.FolderPath = FolderPath
        self.pathToOOMMF = 'C:/Users/bgoul/Documents/oommf20a4/oommf/'
        self.dataPath = FolderPath + dataFile
        gwc = np.array(field_to_import)
        dimsList = gwc[:,1]
        self.dimsList = []
        for dims_ind in range(0, len(dimsList)): 
            self.dimsList.append(int(dimsList[dims_ind]))
        
        if (data == None):  
            print("Importing Data")
            self.data = self.getData()
            print("setting time array")
        else: 
            self.data = data
        self.time = self.data['time']
        
        if (images == None):
            print("Importing Fields")
            for field in field_to_import: 
                print ("path0", field[0])
                print("path1", field[1])
                temp_images, temp_f_t, temp_f_s_avg = self.createImages(FolderPath + field[0], dims = field[1])
                self.images.append(temp_images)
                self.v_t.append(temp_f_t)
                self.v_s_avg.append(temp_f_s_avg)
            
        else: 
            print("Need to add import images case")
        
        self.freq = None #List of frequencies that the FFT spans 
        self.fourierImage = [None]*len(field_to_import) #[field][x][y][dim][freq]
        self.fourierPhaseImage = [None]*len(field_to_import) #[field][x][y][dim][freq]
        self.fourierImage1D = [None]*len(field_to_import) #[field][x][y][freq] spatially averaged after FFT
        self.fourierAverage = [None]*len(field_to_import) #[field][freq]
        self.dimFourierAverage = [None]*len(field_to_import)
        self.s_avg_FT = [None]*len(field_to_import)
        self.peaks = None
        
    def avf2odt(self): 
        dataPath = self.FolderPath
        suc1 = os.system('cd {} & tclsh oommf.tcl avf2odt -ipat "{}*.o*f" -average "point" -headers "none"'.format(self.pathToOOMMF, dataPath))
        print("exit code avf2odt: ", suc1)
#        if (suc1 == 1):
        suc2 = os.system('cd {} & mkdir avfFiles & move *.o*f avfFiles'.format(dataPath))
#        else: 
#            suc2 = -17
        print("exit code to moving avf files: ", suc2) 
            
    def createImages(self, imagePath, dims = 3, exe_avf2odt = True):
        """
        This method is used to read data from the .odt vector field files. It creates 2 multi-dimentional arrays that represent the magnetization data. 
        The method is automatically run upon innitialization of the Simulation class, so it should not be run again. 

        Parameters: None

        Returns: 
        sss: array 
            sss is a multidimentional array that contains all the data from each magnetization profile in sequential order. The shape is sss[t][x][y][m]
        m_t: array
            m_t is a multidimentional array that contains all the data from each magnetization profile in sequential order. The shape is m_t[x][y][m][t]
        """
        print("Checking and changing file format with avf2odt (may take quite a while, depending on how many files must be converted from .avf to .odt)")
        if (exe_avf2odt == True): 
            self.avf2odt()
        sss = []
        v_s_avg = []
        i = 0
        print("Importing Fields")
        if (glob.glob(imagePath) == []):
            print("List of fields is empty, check the filepath")
            
        finalList = []
        for stage in glob.glob(imagePath):
            finalList.append(stage)
        for stage in finalList: 
            shot = pd.read_csv(stage, delim_whitespace=True, header = None, comment = "#")
            self.coords = (shot[0].unique(), shot[1].unique(), shot[2].unique())
            print(len(self.coords[0]))
            print(len(self.coords[1]))
            print(len(self.coords[2]))
            num_x_cells = len(self.coords[0])
            num_y_cells = len(self.coords[1])
            num_z_cells = len(self.coords[2])
            self.coordNums = [num_x_cells,num_y_cells,num_z_cells]
            image = np.zeros((num_z_cells, num_x_cells, num_y_cells, dims))
#            s_avg = [0]*dims
            for z in range(0, num_z_cells):
                for x in range(0, num_x_cells): 
                    for y in range(0, num_y_cells): 
                        num = z*num_y_cells*num_x_cells + x*num_y_cells + y 
                        for dim in range(0, dims):
                            image[z][x][y][dim] = shot[dim+3][num]
    #                        s_avg[dim] = s_avg[dim] + shot[dim+2][num]
    
            sss.append(image)
#            v_s_avg.append(s_avg)
            if (i%100 == 0): 
                print ("Imported ", i, "Fields")
            i += 1
        sss = np.array(sss)
#        v_s_avg = np.array(v_s_avg)
#        v_s_avg = v_s_avg / (num_x_cells*num_y_cells)
#        v_s_avg = v_s_avg.T
        v_s_avg = np.zeros([dims, len(sss)])
        for z in range(0, num_z_cells):
            for t in range(0, len(sss)): 
                for dim in range(0, dims): 
                    v_s_avg[z][dim][t] = np.sum(sss[t,z,:,:,dim])
        v_t = np.zeros((num_z_cells, num_x_cells, num_y_cells, dims, len(sss)))
        print("Transposing data")
        for x in range(0, num_x_cells): 
            for y in range(0, num_y_cells): 
                for z in range(0, num_z_cells):
                    v_t[z][x][y] = sss[:,z,x,y].T
        return sss, v_t, v_s_avg

    def getData(self):
        """
        This method reads the data from the DataTable output by mmArchive from OOMMF. 
        This method is run on initialization of the Simulation class, so it should not be run again. 

        Parameters: Nothing

        Returns: 
        data: array 
            The data table output by OOMMF as an array
        """
        with open(self.dataPath, 'r+') as f:
            content = f.read()
            line = "TotalEnergy EnergyCalcCount max_dmdt dEdt deltaE UniaxialAnisotropyEnergy UniformExchangeEnergy MaxSpinAng StageMaxSpinAng RunMaxSpinAng DemagEnergy Oxs_TimeDriverIteration Oxs_TimeDriverStageIteration Stage mx my mz   LastTimeStep time"
            if (content[0:20] != line[0:20]): 
                f.seek(0, 0)
                f.write(line.rstrip('\r\n') + '\n' + content)

        data = pd.read_csv(self.dataPath, delim_whitespace = True, comment = "#", header = 0)
        return data
